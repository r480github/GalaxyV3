/* tslint:disable */
/* eslint-disable */
/**
*/
export class EpoxyClient {
/**
** Return copy of self without private attributes.
*/
  toJSON(): Object;
/**
* Return stringified version of self.
*/
  toString(): string;
  free(): void;
/**
* @param {any} wisp_url
* @param {EpoxyClientOptions} options
*/
  constructor(wisp_url: any, options: EpoxyClientOptions);
/**
* @returns {Promise<void>}
*/
  replace_stream_provider(): Promise<void>;
/**
* @param {EpoxyHandlers} handlers
* @param {string} url
* @param {(string)[]} protocols
* @param {any} headers
* @returns {Promise<EpoxyWebSocket>}
*/
  connect_websocket(handlers: EpoxyHandlers, url: string, protocols: (string)[], headers: any): Promise<EpoxyWebSocket>;
/**
* @param {EpoxyHandlers} handlers
* @param {string} url
* @returns {Promise<EpoxyIoStream>}
*/
  connect_tcp(handlers: EpoxyHandlers, url: string): Promise<EpoxyIoStream>;
/**
* @param {EpoxyHandlers} handlers
* @param {string} url
* @returns {Promise<EpoxyIoStream>}
*/
  connect_tls(handlers: EpoxyHandlers, url: string): Promise<EpoxyIoStream>;
/**
* @param {EpoxyHandlers} handlers
* @param {string} url
* @returns {Promise<EpoxyUdpStream>}
*/
  connect_udp(handlers: EpoxyHandlers, url: string): Promise<EpoxyUdpStream>;
/**
* @param {string} url
* @param {object} options
* @returns {Promise<Response>}
*/
  fetch(url: string, options: object): Promise<Response>;
/**
*/
  redirect_limit: number;
/**
*/
  user_agent: string;
}
/**
*/
export class EpoxyClientOptions {
  free(): void;
/**
*/
  constructor();
/**
*/
  disable_certificate_validation: boolean;
/**
*/
  pem_files: (string)[];
/**
*/
  redirect_limit: number;
/**
*/
  udp_extension_required: boolean;
/**
*/
  user_agent: string;
/**
*/
  websocket_protocols: (string)[];
/**
*/
  wisp_v2: boolean;
}
/**
*/
export class EpoxyHandlers {
  free(): void;
/**
* @param {Function} onopen
* @param {Function} onclose
* @param {Function} onerror
* @param {Function} onmessage
*/
  constructor(onopen: Function, onclose: Function, onerror: Function, onmessage: Function);
/**
*/
  onclose: Function;
/**
*/
  onerror: Function;
/**
*/
  onmessage: Function;
/**
*/
  onopen: Function;
}
/**
*/
export class EpoxyIoStream {
  free(): void;
/**
* @param {any} payload
* @returns {Promise<void>}
*/
  send(payload: any): Promise<void>;
/**
* @returns {Promise<void>}
*/
  close(): Promise<void>;
}
/**
*/
export class EpoxyUdpStream {
  free(): void;
/**
* @param {any} payload
* @returns {Promise<void>}
*/
  send(payload: any): Promise<void>;
/**
* @returns {Promise<void>}
*/
  close(): Promise<void>;
}
/**
*/
export class EpoxyWebSocket {
  free(): void;
/**
* @param {any} payload
* @returns {Promise<void>}
*/
  send(payload: any): Promise<void>;
/**
* @param {number} code
* @param {string} reason
* @returns {Promise<void>}
*/
  close(code: number, reason: string): Promise<void>;
}
/**
*/
export class IntoUnderlyingByteSource {
  free(): void;
/**
* @param {ReadableByteStreamController} controller
*/
  start(controller: ReadableByteStreamController): void;
/**
* @param {ReadableByteStreamController} controller
* @returns {Promise<any>}
*/
  pull(controller: ReadableByteStreamController): Promise<any>;
/**
*/
  cancel(): void;
/**
*/
  readonly autoAllocateChunkSize: number;
/**
*/
  readonly type: string;
}
/**
*/
export class IntoUnderlyingSink {
  free(): void;
/**
* @param {any} chunk
* @returns {Promise<any>}
*/
  write(chunk: any): Promise<any>;
/**
* @returns {Promise<any>}
*/
  close(): Promise<any>;
/**
* @param {any} reason
* @returns {Promise<any>}
*/
  abort(reason: any): Promise<any>;
}
/**
*/
export class IntoUnderlyingSource {
  free(): void;
/**
* @param {ReadableStreamDefaultController} controller
* @returns {Promise<any>}
*/
  pull(controller: ReadableStreamDefaultController): Promise<any>;
/**
*/
  cancel(): void;
}

export type InitInput = RequestInfo | URL | Response | BufferSource | WebAssembly.Module;

/**
*
* @param {{ module_or_path: InitInput | Promise<InitInput> }} module_or_path 
*
* @returns {Promise<void>}
*/
export default function __wbg_init (module_or_path?: { module_or_path: InitInput | Promise<InitInput> } | InitInput | Promise<InitInput>): Promise<void>;
export const info: { version: string, minimal: boolean, release: boolean };
